import { describe, expect, it } from 'bun:test';
import {
  BaseEntity,
  EntityType,
  SqliteOptions,
} from '../../src/connectors/sqlite/types';

// Test entity for SQLite connector tests
class TestUser extends BaseEntity<TestUser> {
  id?: string;
  name: string;
  email: string;
  age?: number;

  constructor(target?: Partial<TestUser>) {
    super(target);
    this.name = target?.name ?? '';
    this.email = target?.email ?? '';
    this.age = target?.age;
  }
}

class TestProduct extends BaseEntity<TestProduct> {
  id?: string;
  title: string;
  price: number;
  available: boolean;

  constructor(target?: Partial<TestProduct>) {
    super(target);
    this.title = target?.title ?? '';
    this.price = target?.price ?? 0;
    this.available = target?.available ?? true;
  }
}

describe('SQLite Connector - Type Definitions', () => {
  describe('Entity Type Support', () => {
    it('should define TestUser entity correctly', () => {
      const user = new TestUser({
        name: 'John Doe',
        email: 'john@example.com',
        age: 30,
      });

      expect(user.name).toBe('John Doe');
      expect(user.email).toBe('john@example.com');
      expect(user.age).toBe(30);
    });

    it('should support partial entity initialization', () => {
      const user = new TestUser({
        name: 'Jane Doe',
      });

      expect(user.name).toBe('Jane Doe');
      expect(user.email).toBe('');
      expect(user.age).toBeUndefined();
    });

    it('should support empty entity creation', () => {
      const user = new TestUser();
      expect(user).toBeDefined();
    });

    it('should define TestProduct entity correctly', () => {
      const product = new TestProduct({
        title: 'Test Product',
        price: 99.99,
        available: true,
      });

      expect(product.title).toBe('Test Product');
      expect(product.price).toBe(99.99);
      expect(product.available).toBe(true);
    });

    it('should support nullable columns', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'test@example.com',
      });

      expect(user.age).toBeUndefined();
    });

    it('should support default values', () => {
      const product = new TestProduct({
        title: 'Product',
        price: 50.0,
        // available should default to true
      });

      expect(product).toBeDefined();
    });
  });

  describe('Data Type Support', () => {
    it('should support string columns', () => {
      const user = new TestUser({
        name: 'String Test',
        email: 'string@example.com',
      });

      expect(typeof user.name).toBe('string');
    });

    it('should support numeric columns', () => {
      const user = new TestUser({
        name: 'Numeric Test',
        email: 'numeric@example.com',
        age: 25,
      });

      expect(typeof user.age).toBe('number');
      expect(user.age).toBe(25);
    });

    it('should support boolean columns', () => {
      const product = new TestProduct({
        title: 'Boolean Test',
        price: 50.0,
        available: false,
      });

      expect(typeof product.available).toBe('boolean');
    });

    it('should support decimal columns', () => {
      const product = new TestProduct({
        title: 'Decimal Test',
        price: 123.45,
        available: true,
      });

      expect(product.price).toBeDefined();
      expect(typeof product.price).toBe('number');
    });

    it('should support UUID primary keys', () => {
      const user = new TestUser({
        name: 'UUID Test',
        email: 'uuid@example.com',
      });

      // ID would be generated by TypeORM during save
      expect(user).toBeDefined();
    });
  });

  describe('BaseEntity Type', () => {
    it('should extend BaseEntity', () => {
      const user = new TestUser();
      expect(user).toBeInstanceOf(BaseEntity);
    });

    it('should support BaseEntity constructor with partial data', () => {
      const data = {
        name: 'Test User',
        email: 'test@example.com',
      };

      const user = new TestUser(data);

      expect(user.name).toBe(data.name);
      expect(user.email).toBe(data.email);
    });

    it('should work with Object.assign through BaseEntity', () => {
      const user = new TestUser();
      const update = { age: 40 };

      Object.assign(user, update);

      expect(user.age).toBe(40);
    });
  });

  describe('EntityType Generic', () => {
    it('should define EntityType as constructor', () => {
      const entities: EntityType[] = [TestUser, TestProduct];

      expect(entities.length).toBe(2);
      expect(entities[0]).toBe(TestUser);
      expect(entities[1]).toBe(TestProduct);
    });

    it('should accept any entity class', () => {
      class CustomEntity {
        id?: string;
        name: string = '';
      }

      const entities: EntityType[] = [CustomEntity];

      expect(entities).toContain(CustomEntity);
    });

    it('should support empty entity array', () => {
      const entities: EntityType[] = [];

      expect(entities.length).toBe(0);
    });

    it('should support spread operator with entities', () => {
      const baseEntities = [TestUser];
      const allEntities = [...baseEntities, TestProduct];

      expect(allEntities.length).toBe(2);
      expect(allEntities).toContain(TestUser);
      expect(allEntities).toContain(TestProduct);
    });
  });

  describe('SQLiteOptions Type', () => {
    it('should define database option as string', () => {
      const options: Partial<SqliteOptions> = {
        database: ':memory:',
      };

      expect(options.database).toBe(':memory:');
    });

    it('should support file path database', () => {
      const options: Partial<SqliteOptions> = {
        database: './test.db',
      };

      expect(options.database).toContain('.db');
    });

    it('should support migration root option', () => {
      const options: Partial<SqliteOptions> = {
        database: ':memory:',
        migrationRoot: './migrations/sqlite',
      };

      expect(options.migrationRoot).toContain('migrations');
    });

    it('should support WAL mode option', () => {
      const options: Partial<SqliteOptions> = {
        database: ':memory:',
        enableWAL: true,
      };

      expect(options.enableWAL).toBe(true);
    });

    it('should support busy timeout option', () => {
      const options: Partial<SqliteOptions> = {
        database: ':memory:',
        busyTimeout: 5000,
      };

      expect(options.busyTimeout).toBe(5000);
    });

    it('should support all options together', () => {
      const options: Partial<SqliteOptions> = {
        database: ':memory:',
        migrationRoot: './migrations/sqlite',
        enableWAL: true,
        busyTimeout: 5000,
      };

      expect(options.database).toBeDefined();
      expect(options.migrationRoot).toBeDefined();
      expect(options.enableWAL).toBe(true);
      expect(options.busyTimeout).toBe(5000);
    });

    it('should allow partial options', () => {
      const minimalOptions: Partial<SqliteOptions> = {
        database: ':memory:',
      };

      expect(minimalOptions.database).toBeDefined();
      expect(minimalOptions.migrationRoot).toBeUndefined();
      expect(minimalOptions.enableWAL).toBeUndefined();
    });

    it('should support empty partial options', () => {
      const emptyOptions: Partial<SqliteOptions> = {};

      expect(Object.keys(emptyOptions).length).toBe(0);
    });
  });

  describe('SQLite Configuration Combinations', () => {
    it('should combine database with WAL and timeout', () => {
      const config: Partial<SqliteOptions> = {
        database: ':memory:',
        enableWAL: true,
        busyTimeout: 10000,
      };

      expect(config.database).toBe(':memory:');
      expect(config.enableWAL).toBe(true);
      expect(config.busyTimeout).toBe(10000);
    });

    it('should combine database with migrations', () => {
      const config: Partial<SqliteOptions> = {
        database: './app.db',
        migrationRoot: './migrations/sqlite',
      };

      expect(config.database).toContain('app.db');
      expect(config.migrationRoot).toContain('migrations');
    });

    it('should support in-memory with all options', () => {
      const config: Partial<SqliteOptions> = {
        database: ':memory:',
        migrationRoot: './migrations/sqlite',
        enableWAL: false,
        busyTimeout: 3000,
      };

      expect(config.database).toBe(':memory:');
      expect(config.migrationRoot).toBeDefined();
      expect(config.enableWAL).toBe(false);
      expect(config.busyTimeout).toBe(3000);
    });

    it('should support file-based with all options', () => {
      const config: Partial<SqliteOptions> = {
        database: './data/app.db',
        migrationRoot: './migrations/sqlite',
        enableWAL: true,
        busyTimeout: 5000,
      };

      expect(config.database).toContain('app.db');
      expect(config.enableWAL).toBe(true);
    });
  });

  describe('Multiple Entity Types Configuration', () => {
    it('should configure multiple entities', () => {
      const entities: EntityType[] = [TestUser, TestProduct];
      const options: Partial<SqliteOptions> = {
        database: ':memory:',
      };

      expect(entities.length).toBe(2);
      expect(options.database).toBe(':memory:');
    });

    it('should handle three or more entities', () => {
      class TestOrder extends BaseEntity<TestOrder> {
        id?: string;
        orderNumber: string;

        constructor(target?: Partial<TestOrder>) {
          super(target);
          this.orderNumber = target?.orderNumber ?? '';
        }
      }

      const entities: EntityType[] = [TestUser, TestProduct, TestOrder];

      expect(entities.length).toBe(3);
      expect(entities).toContain(TestUser);
      expect(entities).toContain(TestProduct);
      expect(entities).toContain(TestOrder);
    });

    it('should support variadic entity arguments', () => {
      const firstEntity = TestUser;
      const secondEntity = TestProduct;

      const entities = [firstEntity, secondEntity];

      expect(entities.length).toBe(2);
    });
  });

  describe('Column Decorators', () => {
    it('should support @Column decorator', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'test@example.com',
      });

      expect(user.name).toBeDefined();
      expect(user.email).toBeDefined();
    });

    it('should support @Column with unique constraint', () => {
      const user1 = new TestUser({
        name: 'User 1',
        email: 'unique@example.com',
      });

      expect(user1.email).toBe('unique@example.com');
    });

    it('should support @Column with nullable', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'test@example.com',
      });

      expect(user.age).toBeUndefined();
    });

    it('should support @Column with type and options', () => {
      const product = new TestProduct({
        title: 'Test',
        price: 99.99,
        available: true,
      });

      expect(product.price).toBeDefined();
      expect(product.available).toBeDefined();
    });

    it('should support @Column with default value', () => {
      const product = new TestProduct({
        title: 'Test',
        price: 50.0,
      });

      expect(product).toBeDefined();
    });
  });

  describe('Entity Decorators', () => {
    it('should decorate entity with @Entity', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'test@example.com',
      });

      expect(user).toBeDefined();
    });

    it('should set table name through @Entity', () => {
      // Entity decorator defines the table name
      const user = new TestUser();
      const product = new TestProduct();

      expect(user).toBeInstanceOf(TestUser);
      expect(product).toBeInstanceOf(TestProduct);
    });
  });

  describe('Primary Key Generation', () => {
    it('should support @PrimaryGeneratedColumn with uuid', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'test@example.com',
      });

      expect(user).toBeDefined();
    });

    it('should support multiple entities with generated IDs', () => {
      const user = new TestUser({
        name: 'Test User',
        email: 'user@example.com',
      });

      const product = new TestProduct({
        title: 'Test Product',
        price: 99.99,
        available: true,
      });

      expect(user).toBeDefined();
      expect(product).toBeDefined();
    });
  });

  describe('SQLite Entity Patterns', () => {
    it('should support entity with string properties', () => {
      const user = new TestUser({
        name: 'John',
        email: 'john@example.com',
      });

      expect(user.name).toBe('John');
      expect(user.email).toBe('john@example.com');
    });

    it('should support entity with numeric properties', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'test@example.com',
        age: 30,
      });

      expect(user.age).toBe(30);
    });

    it('should support entity with boolean properties', () => {
      const product = new TestProduct({
        title: 'Test',
        price: 50.0,
        available: true,
      });

      expect(product.available).toBe(true);
    });

    it('should support entity with decimal properties', () => {
      const product = new TestProduct({
        title: 'Test',
        price: 123.45,
        available: false,
      });

      expect(product.price).toBe(123.45);
    });

    it('should support entity with optional properties', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'test@example.com',
      });

      expect(user.age).toBeUndefined();
    });

    it('should support entity with unique constraints', () => {
      const user = new TestUser({
        name: 'Test',
        email: 'unique@example.com',
      });

      expect(user.email).toBe('unique@example.com');
    });
  });
});
